<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Garbage Time Scoring Tracker</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        // SVG Icons (unchanged)
        const AlertTriangle = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
                <path d="M12 9v4"/>
                <path d="M12 17h.01"/>
            </svg>
        );

        const Clock = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
            </svg>
        );

        const TrendingDown = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polyline points="23 18 13.5 8.5 8.5 13.5 1 6"/>
                <polyline points="17 18 23 18 23 12"/>
            </svg>
        );

        const Plus = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M5 12h14"/>
                <path d="M12 5v14"/>
            </svg>
        );

        const Filter = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/>
            </svg>
        );

        function GarbageTimeScoringTracker() {
          const [games, setGames] = useState([]);
          const [filteredGames, setFilteredGames] = useState([]);
          const [showAddGame, setShowAddGame] = useState(false);
          const [filters, setFilters] = useState({
            searchTerm: '',
            minTimeLeft: 0,
            maxTimeLeft: 30,
            minDeficit: 8,
            maxDeficit: 20,
            spreadImpact: 'all'
          });
          
          const [newGame, setNewGame] = useState({
            date: '',
            homeTeam: '',
            awayTeam: '',
            finalScore: '',
            finalOpponentScore: '',
            spread: '',
            timeLeft: '',
            deficitBefore: '',
            pointsScored: '',
            deficitAfter: '',
            scoringTeam: 'home',
            notes: ''
          });

          const [oddsApiKey, setOddsApiKey] = useState('YOUR_ODDS_API_KEY'); // Replace with your key

          const analyzeSpreadImpact = (game) => {
            const finalMargin = game.scoringTeam === 'home' 
              ? game.finalScore - game.finalOpponentScore
              : game.finalOpponentScore - game.finalScore;
            
            const marginBefore = -game.deficitBefore;
            const marginAfter = -game.deficitAfter;
            
            const wasUnderdog = game.spread > 0;
            const wouldNotHaveCovered = marginBefore < -game.spread;
            const didCover = marginAfter > -game.spread;
            
            const spreadDifference = Math.abs(marginAfter + game.spread);
            const wouldHaveMissedBy = Math.abs(marginBefore + game.spread);
            
            const impactedSpread = wouldNotHaveCovered && didCover;

            let score = 0;
            
            if (game.timeLeft <= 15 && game.deficitBefore >= 10) score += 40;
            else if (game.timeLeft <= 20 && game.deficitBefore >= 10) score += 30;
            else if (game.timeLeft <= 30 && game.deficitBefore >= 8) score += 20;
            
            if (impactedSpread) score += 50;
            
            if (game.pointsScored >= 5 && game.timeLeft <= 20) score += 25;
            if (game.pointsScored >= 7 && game.timeLeft <= 30) score += 35;
            
            if (spreadDifference <= 1 && impactedSpread) score += 30;
            if (spreadDifference <= 2 && impactedSpread) score += 20;
            
            if (game.deficitBefore >= 12 && game.timeLeft <= 20) score += 15;
            
            const suspicionScore = Math.min(score, 100);

            return {
              finalMargin,
              marginBefore,
              marginAfter,
              wasUnderdog,
              coveredSpread: didCover,
              wouldHaveCovered: !wouldNotHaveCovered,
              impactedSpread,
              spreadDifference,
              wouldHaveMissedBy,
              suspicionScore
            };
          };

          useEffect(() => {
            const savedGames = localStorage.getItem('garbageTimeGames');
            if (savedGames) {
              const parsed = JSON.parse(savedGames);
              setGames(parsed);
              setFilteredGames(parsed);
            } else {
              // Sample games (unchanged)
              const sampleGames = [
                // ... (keep your sample games here)
              ];

              const gamesWithAnalysis = sampleGames.map(game => ({
                ...game,
                ...analyzeSpreadImpact(game)
              }));

              setGames(gamesWithAnalysis);
              setFilteredGames(gamesWithAnalysis);
            }
          }, []);

          useEffect(() => {
            if (games.length > 0) {
              localStorage.setItem('garbageTimeGames', JSON.stringify(games));
            }
          }, [games]);

          useEffect(() => {
            // Filter logic (unchanged)
            // ...
          }, [games, filters]);

          const handleAddGame = () => {
            // Manual add logic (unchanged)
            // ...
          };

          const getSuspicionLevel = (score) => {
            // Unchanged
            // ...
          };

          // New: Function to fetch and analyze recent games
          const fetchRecentGames = async () => {
            try {
              // Step 1: Fetch recent games from balldontlie (free, last 7 days example)
              const today = new Date();
              const sevenDaysAgo = new Date(today);
              sevenDaysAgo.setDate(today.getDate() - 7);
              const dates = [];
              for (let d = sevenDaysAgo; d <= today; d = new Date(d.setDate(d.getDate() + 1))) {
                dates.push(d.toISOString().slice(0, 10));
              }
              const bdlGames = [];
              for (const date of dates) {
                const res = await fetch(`https://www.balldontlie.io/api/v1/games?dates[]=${date}`);
                const data = await res.json();
                bdlGames.push(...data.data);
              }

              // Step 2: Fetch historical odds from The Odds API for recent dates
              const oddsByDate = {};
              for (const date of dates) {
                const oddsRes = await fetch(`https://api.theoddsapi.com/v4/sports/basketball_nba/odds-history/?apiKey=${oddsApiKey}&date=${date}&regions=us&markets=spreads&oddsFormat=american`);
                const oddsData = await oddsRes.json();
                oddsByDate[date] = oddsData.data;
              }

              // Step 3: For each completed game, fetch play-by-play from NBA CDN and analyze
              const newGames = [];
              for (const bdlGame of bdlGames) {
                if (bdlGame.status !== 'Final') continue; // Only completed games

                // Map to NBA game ID (balldontlie has 'game_id', but use team/date to match)
                const gameDate = bdlGame.date.slice(0,10);
                const homeTeam = bdlGame.home_team.full_name;
                const awayTeam = bdlGame.visitor_team.full_name;
                const finalScore = bdlGame.home_team_score; // Assume home scoring team for now; adjust based on analysis
                const finalOpponentScore = bdlGame.visitor_team_score;

                // Fetch play-by-play (need NBA game ID; assume format 002{year}0{sequence}, but for simplicity, skip if not known. In practice, use nba_api or search for ID)
                // To get NBA game ID, you can add logic to fetch from scoreboard or schedule. For demo, assume we have it or skip detailed parse
                // Placeholder: Fetch example playbyplay (replace with actual)
                const gameId = '0022500001'; // Replace with real logic to get ID (e.g., from schedule fetch)
                const pbpRes = await fetch(`https://cdn.nba.com/static/json/liveData/playbyplay/playbyplay_${gameId}.json`);
                const pbpData = await pbpRes.json();
                const actions = pbpData.game.actions;

                // Analyze for garbage time
                let garbageTimeEvent = null;
                let deficitBefore = 0;
                let pointsScored = 0;
                let timeLeft = 0;
                let scoringTeam = 'home'; // Determine based on who scored
                for (let i = actions.length - 1; i >= 0; i--) {
                  const action = actions[i];
                  if (action.period === 4 && parseClock(action.clock) <= 30) {
                    if (isScoringAction(action.description)) {
                      // Calculate deficit before this action (use previous score)
                      const prevAction = actions[i-1];
                      const prevHome = prevAction ? prevAction.scoreHome : action.scoreHome - pointsFromDescription(action.description);
                      const prevAway = prevAction ? prevAction.scoreAway : action.scoreAway - pointsFromDescription(action.description);
                      deficitBefore = Math.abs(prevHome - prevAway);
                      if (deficitBefore >= 10) {
                        pointsScored = pointsFromDescription(action.description);
                        timeLeft = parseClock(action.clock);
                        scoringTeam = action.teamTricode === bdlGame.home_team.abbreviation ? 'home' : 'away';
                        garbageTimeEvent = action;
                        break;
                      }
                    }
                  }
                }

                if (!garbageTimeEvent) continue; // No qualifying event

                // Get spread from odds
                const oddsForGame = oddsByDate[gameDate].find(g => g.home_team === homeTeam && g.away_team === awayTeam);
                const spread = oddsForGame ? getAverageSpread(oddsForGame.bookmakers) : 0; // Placeholder function to average spreads

                const deficitAfter = deficitBefore - pointsScored;

                const gameData = {
                  id: games.length + 1,
                  date: gameDate,
                  homeTeam,
                  awayTeam,
                  finalScore,
                  finalOpponentScore,
                  spread,
                  timeLeft,
                  deficitBefore,
                  pointsScored,
                  deficitAfter,
                  scoringTeam,
                  notes: 'Auto-fetched garbage time event'
                };

                const gameWithAnalysis = {
                  ...gameData,
                  ...analyzeSpreadImpact(gameData)
                };

                newGames.push(gameWithAnalysis);
              }

              setGames([...games, ...newGames]);
            } catch (error) {
              console.error('Error fetching games', error);
              alert('Error fetching data. Check console for details.');
            }
          };

          // Helper functions (add these)
          const parseClock = (clock) => {
            const [min, sec] = clock.replace('PT', '').replace('M', ':').replace('.00S', '').split(':');
            return parseInt(min) * 60 + parseInt(sec);
          };

          const isScoringAction = (desc) => {
            return desc.includes('MADE') || desc.includes('FREE THROW');
          };

          const pointsFromDescription = (desc) => {
            if (desc.includes('3PT')) return 3;
            if (desc.includes('FREE THROW')) return 1;
            return 2; // Default for 2PT
          };

          const getAverageSpread = (bookmakers) => {
            const spreads = bookmakers.flatMap(b => b.markets.find(m => m.key === 'spreads')?.outcomes || []);
            const avg = spreads.reduce((sum, o) => sum + o.point, 0) / spreads.length;
            return avg || 0;
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-red-50 via-slate-50 to-orange-50 p-4">
              <div className="max-w-7xl mx-auto">
                <div className="bg-white rounded-lg shadow-xl p-6 mb-6 border-t-4 border-red-600">
                  // ... (keep the rest of the UI unchanged, but add the fetch button next to Add Game)
                  <div className="flex items-center justify-between mb-4 flex-wrap gap-4">
                    // ... existing header
                    <button
                      onClick={fetchRecentGames}
                      className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition flex items-center gap-2"
                    >
                      Fetch Recent Games
                    </button>
                  </div>
                  // ... rest of UI
                </div>
                // ... (keep the rest of the return statement unchanged)
              </div>
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GarbageTimeScoringTracker />);
    </script>
</body>
</html>
